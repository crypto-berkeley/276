

% !TEX root = collection.tex

\section{BLS Signatures}

\paragraph{Bilinear Pairings.} Recall that we used prime order groups $\mathbb{G}$ to build the Schnorr signature scheme. Today we will introduce another mathematical object, pairing friendly groups, which support a new ``bilinear pairing'' operation defined as follows. Let $\mathbb{G}_1$, $\mathbb{G}_2$ and $\mathbb{G}_T$ be groups of prime order $p$. We define a bilinear pairing $e: G_1 \times G_2 \rightarrow \mathbb{G}_T$ to be an \emph{efficiently} computable map that satisfies the following properties:
\begin{itemize}
    \item Bilinearity: For all $a, b \in \mathbb{Z}_p$ and $g_1 \in G_1, g_2 \in G_2$, we have $e(g_1^a, g_2^b) = e(g_1, g_2)^{ab}$.
    \item Non-degenerate: $e(g_1, g_2) \neq 1_{\mathbb{G}_T}$.
\end{itemize}
Observe that in any group, by using the group operation, one can compute ``additions'' of the scalar exponents, but in pairing friendly groups one can additionally compute \emph{one} ``multiplication'' of the scalar exponents.

Note that while a pairing provides us with additional \emph{functionality}, it also means that we need to reevaluate any hardness assumptions that we have made. Consider for instance the decisional Diffie-Hellman (DDH) assumption which states that it is hard to distinguish between $(g, g^a, g^b, g^{ab})$ and $(g, g^a, g^b, g^c)$ for random $a, b, c \in \mathbb{Z}_p$. In the presence of a bilinear pairing, natural variants of the DDH assumption are no longer hard such as distinguishing between $(g_1, g_2, g_1^a, g_2^b, g_1^{ab})$ and $(g_1, g_2, g_1^a, g_2^b, g_1^{c})$. Instead, we will define new assumptions that are conjectured to be hard even given a bilinear pairing.

\paragraph{co-CDH assumption.} Let $\mathbb{G}_1$, $\mathbb{G}_2$ be groups of prime order with generators $g_1$ and $g_2$ and let $e: \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$ be an efficiently computable bilinear pairing. The co-CDH assumption states that for all non-uniform PPT adversaries $\adv$:
\begin{align*}
    \Pr\left[ \adv(g_1, g_2, g_1^a, g_1^b, g_2^b) \to g_1^{ab} \mid a,b \sample \mathbb{Z}_p \right] \leq \negl
\end{align*}

\paragraph{BLS Signature scheme.} We are now ready to describe the BLS signature scheme \cite{AC:BonLynSha01}.
\begin{itemize}
    \item $\Gen(1^\lambda)$: Sample $\sk \sample \mathbb{Z}_p$ and set $\vk \gets g_2^\sk$. Output $(\vk, \sk)$.
    \item $\Sign(\sk, m)$: Given a message $m \in \{0,1\}^*$, output $\sigma \gets H(m)^{\sk}$, where $H: \{0,1\}^* \to \mathbb{G}_1$ is a hash function that maps arbitrary strings to elements in $\mathbb{G}_1$.
    \item $\Verify(\vk, m, \sigma)$: Output $e(\sigma, g_2) \stackrel{?}{=} e(H(m), \vk)$.
\end{itemize}

\paragraph{Correctness.} Correctness is easy to see by plugging in explicit expressions for the signature and verification key -- $e(\sigma=H(m)^\sk, g_2) \stackrel{?}{=} e(H(m), \vk=g_2^\sk)$.

\paragraph{Security.} If $H$ is modelled as a random oracle, we will show that if there exists an adversary $\adv$ that can forge a signature with non-negligible probability, then we can use $\adv$ to build $\advb$ that can solve the co-CDH problem with non-negligible probability.

\begin{theorem}
    The BLS signature scheme is is existentially unforgeable under chosen message attacks assuming the co-CDH problem is hard in the random oracle model.
\end{theorem}

\begin{proof}
    We will use a similar strategy as in the proof of RSA full domain hash. Let $\adv$ be a non-uniform PPT adversary that can forge a signature with non-negligible probability. We will use $\adv$ to build a non-uniform PPT adversary $\advb$ that can solve the co-CDH problem with non-negligible probability.
    $\advb$ works as follows:
    \begin{itemize}
        \item $\advb$ receives $(g_1, g_2, g_1^a, g_1^b, g_2^b)$ as input and is tasked with computing $g_1^{ab}$.
        \item $\advb$ now runs the EUF-CMA game with $\adv$ where $\adv$ makes signing queries and in the end outputs a forgery $(m^*, \sigma^*)$, where $m^*$ has not been previously queried.
        \item At the start of the protocol, $\advb$ sets $\vk = g_1^b$ and sends it to $\adv$. For all random oracle queries $H(m)$, $\adv$ samples $r \sample \mathbb{Z}_p$ and sets $H(m) = g_1^r$. When $\adv$ asks for a signature on $m_i$, $\advb$ samples $r_i \sample \mathbb{Z}_p$ and sets $H(m_i) = g_1^{r_i}$ (if the query has not been previously made). It then responds with $\sigma_i = H(m_i)^b = (g_1^b)^{r_i}$. However, for a randomly chosen index $i^*$ (out of the maximum number of queries $\adv$ can make), $\advb$ sets $H(m_{i^*}) = g_1^a$. Now, if $\adv$ asks for a signature on the chosen $m_{i^*}$, $\advb$ aborts and restarts the EUF-CMA game. In the ends, $\adv$ outputs a forgery with non-negligible probability. And since there are only a polynomial number of queries, $\adv$ outputs a forgery on $m_{i^*}$ with non-negligible probability. In which case $\advb$ outputs $\sigma_{i^*}$ as its output in the co-CDH game.
    \end{itemize}

    We now analyze the probability that $\advb$ solves the co-CDH problem.
    \begin{align*}
        \Pr[\advb \to g_1^{ab}] & = \Pr[\adv \text{ outputs forgery} \wedge m_{i^*} \text{ was not queried} \wedge \text{forgery on } m_{i^*}] \\
                                & \geq \epsilon \times \left( 1 -\frac{1}{q_h}\right)^{q_s} \times \frac{1}{q_h}
    \end{align*}
    which is non-negligible.
    Thus, by contradiction, the BLS signature scheme is existentially unforgeable under chosen message attacks assuming the co-CDH problem is hard in the random oracle model.
\end{proof}


\section*{Exercises}
\begin{exercise}
\textbf{Digital signature schemes can be made deterministic.} Given a digital signature scheme $(\mathsf{Gen}, \mathsf{Sign}, \mathsf{Verify})$ for which $\mathsf{Sign}$ is probabilistic, provide a construction of a digital signature scheme $(\mathsf{Gen}', \mathsf{Sign}', \mathsf{Verify}')$ where $\mathsf{Sign}'$ is deterministic.
\end{exercise}

\chapter{Public Key Encryption}
Public key encryption allows two parties
to communicate with each other with the guarantees of privacy for their messages against an eavesdropper who monitors all communication between the two parties. Recall that we were able to build Digital Signatures and Symmetric Key Encryption, from the weakest building block in cryptography -- one-way functions. However, there are lower bounds
~\cite{STOC:ImpRud89} 
suggesting that public key encryption cannot be built from one-way functions alone. Instead, we will build public key encryption from more structured assumptions (which are a \emph{stronger} assumption in the sense that they imply one-way functions).

\section{Definitions}
\begin{definition}[Public Key Encryption]
    A public key encryption scheme is a tuple of three algorithms $(\gen$, $\enc, \dec)$ defined as follows:
    \begin{itemize}
        \item $\gen(1^\secpar) \to (\pk, \sk)$: outputs a public key and secret key $(\pk, \sk)$.

        \item $\enc(\pk, m) \to c$: Takes as input the public key and a message $m$ and outputs a ciphertext $c$.

        \item $\dec(\sk, c) \to m$: Takes as input a secret key $\sk$ and ciphertext $c$, and output a message $m$.
    \end{itemize}
\end{definition}

\begin{definition}[Perfect Correctness]
    A public key encryption scheme $(\gen$, $\enc, \dec)$ is said to be correct if for all $\secpar \in \mathbb{N}$, $(\pk, \sk) \gets \gen(1^\secpar)$, $m \in \{0,1\}^*$, it holds that
    \[\Pr[\dec(\sk, \enc(\pk, m)) = m] = 1\]
\end{definition}
The above definition can be relaxed to allow for a negligible probability of error during decryption and still remain meaningful.

We now define two different notions of security for public key encryption schemes -- IND-CPA and IND-CCA security.
\begin{definition}[IND-CPA Security]
    A public key encryption scheme $(\gen$, $\enc, \dec)$ is said to be IND-CPA-secure if for all non-uniform PPT $\adv$,
    \[\left|\Pr[\mathsf{Exp}_{\adv}^{\mathsf{CPA}(\secpar)} = 1] - \frac{1}{2}\right| \leq \negl,\]
    where $\mathsf{Exp}_{\adv}^{\mathsf{CPA}(\secpar)}$ is defined as follows:
    \begin{itemize}
        \item $(\pk, \sk) \gets \gen(1^\secpar)$.
        \item $b \sample \{0,1\}$.
        \item $\adv(\pk) \to (m_0, m_1, \mathsf{st})$.
        \item $c^* \gets \enc(\pk, m_b)$.
        \item $\adv(c^*, \mathsf{st}) \to b'$.
        \item Output $1$ if $b = b'$ and $0$ otherwise.
    \end{itemize}
\end{definition}

\begin{definition}[IND-CCA Security]
    A public key encryption scheme $(\gen$, $\enc, \dec)$ is said to be IND-CCA-secure if for all non-uniform PPT $\adv$,
    \[\left|\Pr[\mathsf{Exp}_{\adv}^{\mathsf{CCA}(\secpar)} = 1] - \frac{1}{2}\right| \leq \negl,\]
    where $\mathsf{Exp}_{\adv}^{\mathsf{CCA}(\secpar)}$ is defined as follows:
    \begin{itemize}
        \item $(\pk, \sk) \gets \gen(1^\secpar)$.
        \item $b \sample \{0,1\}$.
        \item $\adv^{\Dec(\sk)}(\pk) \to (m_0, m_1, \mathsf{st})$.
        \item $c^* \gets \enc(\pk, m_b)$.
        \item $\adv^{\Dec(\sk)}(c^*, \mathsf{st}) \to b'$, where the decryption oracle now returns $\bot$ when queried on $c^*$.
        \item Output $1$ if $b = b'$ and $0$ otherwise.
    \end{itemize}
\end{definition}

\section{Trapdoor Functions}
\begin{definition}[Trapdoor Function]
    A trapdoor function is a tuple of four algorithms $(\gen, f, f^{-1}, D)$ defined as follows:
    \begin{itemize}
        \item $\gen(1^\secpar) \to (s,t)$: outputs an index $s$ and corresponding trapdoor $t$.
        \item $D(s)$: Outputs a description of the domain of the trapdoor function.
        \item $f(s, x) \to y$: Takes as input an index $s$ and a element $x$ from the domain of the trapdoor function and outputs an element $y$.
        \item $f^{-1}(t, y) \to x$: Takes as input a trapdoor $t$ and an element $y$ from the range of the trapdoor function and outputs an element $x$.
    \end{itemize}
    We require the following properties:
    \begin{itemize}
        \item \textbf{Correctness:} For all $\secpar \in \mathbb{N}$, $(s,t) \gets \gen(1^\secpar)$, $x \in D(s)$, it holds that $\Pr[f^{-1}(t, f(s, x)) \neq x] = \negl$. Note that if we demand that $f$ is injective, then this property is automatically satisfied.
        \item \textbf{One-wayness:} For all non-uniform PPT $\adv$, we have $\Pr[\adv(s, y) \to x \mid (s,t) \gets \gen(1^\secpar), x \sample D(s), y \gets f(s, x)] = \negl$.
    \end{itemize}
\end{definition}

\section{Public Key Encryption from Trapdoor Functions}
Given a trapdoor function, we can build a public key encryption scheme as follows:
\begin{itemize}
    \item $\gen(1^\secpar)$: Run $\mathsf{TDF}.\gen(1^\secpar)$ to obtain $(s,t)$. Set $\pk = s$ and $\sk = t$.
    \item $\enc(\pk, m)$: Sample $x \sample D(s)$ and compute $y \gets f(s, x)$. Sample $r \sample \{0,1\}^{|x|}$ and output $c = (y, r, m \oplus \mathsf{HC}(x,r))$, where $\mathsf{HC}$ is the hardness concentration bit, as defined in~Section~\ref{sec:levin-owf}.
    \item $\dec(\sk, c)$: Parse $c = (y, r, z)$ and output $m = z \oplus \mathsf{HC}(f^{-1}(t, y), r)$.
\end{itemize}

\paragraph{Proof Sketch.} To show that the above scheme is CPA secure, observe that the message space $\{0,1\}$. So the only two messages the distinguisher can pick are $m_0=0$ and $m_1=1$. Now if the distinguisher can indeed distinguish between encryptions of $m_0$ and $m_1$, then the same distinguisher can be used to identify the hardness concentration bit. By using a similar strategy as in the proof of~Theorem~\ref{thm:hard-concentrate-bit}, we can recover the pre-image $x$ of the trapdoor function. Thus, violating the one-wayness of the trapdoor function.

\section{Public Key Encryption from Computational Diffie-Hellman}
Although we have a construction of public key encryption from trapdoor functions, we did not know how to build trapdoor functions from some very natural assumptions such as CDH for quite some time. It was only recently that Garg and Hajiabadi~\cite{C:GarHaj18} 
showed that this was indeed possible. Given the non-trivial nature of the construction, we will not cover it in this course and instead provide a \emph{direct} construction of public key encryption from the Computational Diffie-Hellman (CDH) assumption.

Let $\mathbb{G}$ be a prime order group of order $p$ with generator $g$, where the CDH problem is assumed to be hard.
\begin{itemize}
    \item $\gen(1^\secpar)$: Sample $\sk \sample \mathbb{Z}_p$ and set $\pk \gets g^\sk$. Output $(\pk, \sk)$.
    \item $\enc(\pk, m)$: Sample $\alpha \sample \mathbb{Z}_p$, and set $y \gets g^\alpha$, $k \gets \pk^\alpha$. Now sample $r \sample \{0,1\}^{|B|}$ and output $c = (y, r, m \oplus \mathsf{HC}(k, r))$.
    \item $\dec(\sk, c)$: Parse $c = (y, r, z)$ and compute $k \gets y^\sk$. Output $m = z \oplus \mathsf{HC}(k, r)$.
\end{itemize}

\paragraph{Proof Sketch.} The proof of security is similar to the proof of security for the trapdoor function based public key encryption scheme. The only difference is that we now we reduce the hardness of the CDH problem.

\section{Improving Efficiency.}
The above construction can only be used to encrypt a single bit and results in a ciphertext of size $O(\poly)$. Encrypting a message with $M$ bits, results in a ciphertext of size $O(M \cdot \poly)$. Encryption and decryption also requires $O(M)$ public-key operations (evaluating the TDF/group operations) and we would like to bring this down to $O(1)$. The idea is to extract a symmetric key instead of a single bit by replacing the hardness concentration function with a random oracle. We can then use the symmetric key to encrypt long message with constant rate.

The construction is almost identical except that we replace the hardness concentration bit with a random oracle to extract a symmetric key that can be used to encrypt a long message. Given a trapdoor function the construction works as follows:
\begin{itemize}
    \item $\gen(1^\secpar)$: Run $\mathsf{TDF}.\gen(1^\secpar)$ to obtain $(s,t)$. Set $\pk = s$ and $\sk = t$.
    \item $\enc(\pk, m)$: Sample $x \sample D(s)$ and compute $y \gets f(s, x)$. Encrypt $m$ using a symmetric encryption scheme with key $H(x)$ as $z \gets \mathsf{Sym}.\enc(H(x), m)$. Output $c = (y, z)$.
    \item $\dec(\sk, c)$: Parse $c = (y, z)$ and compute $x \gets f^{-1}(t, y)$. Decrypt $z$ using the symmetric encryption scheme with key $H(x)$ as $m \gets z \oplus \mathsf{Sym}.\dec(H(x), z)$. Output $m$.
\end{itemize}
The same idea can be extended to the CDH based public key encryption scheme.

\begin{theorem}
    The construction above is IND-CPA secure in the random oracle model assuming $f$ is a trapdoor function.
\end{theorem}
\begin{proof}
    Given an adversary $\adv$ that can win the IND-CPA game, with non-negligible advantage, we construct an adversary $\advb$ that can break either the one-wayness of the trapdoor function or the security of the with non-negligible advantage.

    Let $s, y^*$ be the challenge given to $\advb()$. $\advb$ provides $\adv$ with $\pk \coloneq s$. $\adv$ outputs $(m_0, m_1)$ and in response $\advb$ computes a challenge ciphertext as follows: Sample $b \sample \{0,1\}$, a random key $k^* \sample \{0,1\}^{|B|}$ and set $z^* \gets \mathsf{Sym}.\enc(k^*, m_b)$. $\advb$ also lazily samples responses to random oracle queries except if a query $q$ satisfies $f(s, q) = y^*$, then $\advb$ sets $H(q) = k^*$, and outputs $q$ as the inverse image of $y^*$ under $f$.

    We now argue that $\adv$ queries the random oracle on an element $q$ such that $f(s, q) = y^*$, with non-negligible probability. If this never occurs, then $\adv$ never receives receive $k^*$ but is able to distinguish symmetric-key encryptions of $m_0$ from encryptions of $m_1$ with non-negligible probability. This violates the security of the symmetric encryption scheme. Thus, $\adv$ must query the random oracle on an element $q$ such that $f(s, q) = y^*$ with non-negligible probability and hence $\advb$ succeeds with non-negligible probability.
\end{proof}

\section{Fujisaki-Okamoto Transformation}


\section{Post-Quantum Public Key Encryption}
The public-key encryption schemes discussed so far, rely on the difficulty of problems like factorization or discrete logarithms. In 1994, Peter Shor showed that these problems can be solved efficiently on a quantum computer~\cite{FOCS:Shor94}. Even though we do not have large-scale quantum computers capable of breaking current encryption schemes, there are two reasons to begin the transition of public-key encryption to quantum-resistant schemes:
\begin{itemize}
    \item Encrypted messages captured today can be stored and decrypted in the future when a large scale quantum computer is available. This is commonly referred to as the "harvest now, decrypt later" risk.
    \item Transition to new encryption schemes is a slow process and it is important to start the transition well before large scale quantum computers are available.
\end{itemize}

The national institute of standards and technology (NIST) opened a call for post-quantum public-key encryption and signature schemes in 2016. In Nov 2019, it received 59 submissions for public-key encryption and 23 submissions for digital signatures. In July 2022, NIST announced the first batch of winners for public-key encryption and digital signatures. In Aug 2024, the final standard for these schemes was published and they are now making their way into existing infrastructure. There was one winner (CRYSTALS-Kyber) for public-key encryption (based on lattices) and three winners for digital signatures (two based on lattices and one based on hash functions).

\begin{figure}[!htbp]
    \begin{tikzpicture}[node distance=1.5cm and 2cm,
            every node/.style={align=center}, % Adjust width as needed
            >=stealth] % Nicer arrow tips
        \node[align=center](lwe) {LWE \\ \citep{STOC:Regev05}};
        \node[right=of lwe] (lweske) {LWE-SKE};
        \node[right=of lweske, align=center] (lwepke) {LWE-PKE \\ \citep{STOC:Regev05} \\ LWE + LHL };
        \node[right=of lwepke, align=center] (comlwepke) {Compact LWE-PKE \\ \citep{RSA:LinPei11} \\ LWE + LWE};
        \node[below=of lweske, align=center] (rlwe) {RLWE \\ \citep{EC:LyuPeiReg10}};
        \node[right=of rlwe, align=center] (rlwepke) {RLWE-PKE \\ \citep{EC:LyuPeiReg13} \\ RLWE + RLWE};
        \node[below=of rlwe, align=center] (mlwe) {MLWE \\ \citep{ITCS:BraGenVai12,DCC:LanSte15}};
        \node[below=of comlwepke, align=center] (kyber) {CRYSTALS-Kyber \\ MLWE + MLWE};

        \draw[->] (lwe) -- (lweske);
        \draw[->] (lweske) -- (lwepke);
        \draw[->] (lwepke) -- (comlwepke);
        \draw[->] (lwe) -- (rlwe);
        \draw[->] (lwe) -- (mlwe);
        \draw[->] (rlwe) -- (rlwepke);
        \draw[->] (comlwepke) -- (rlwepke);
        \draw[->] (mlwe) -- (kyber);
        \draw[->] (comlwepke) -- (kyber);
        \draw[->] (rlwepke) -- (kyber);
        % Bounding box
        % \draw[dashed, thick] ($(lwe.north west)+(-0.5,0.5)$) rectangle ($(kyber.south east)+(0.5,-3)$);
    \end{tikzpicture}
    \caption{A roadmap of lattice-based public-key encryption schemes ending in the standardized CRYSTALS-Kyber scheme.}
\end{figure}


\begin{definition}[Learning With Errors Assumption (Search)]
    Let $m,n,q \in \mathbb{N}$ and $\chi$ be a distribution over $\mathbb{Z}_q$. The Learning With Errors (LWE) $\LWE_{n,m,q,\chi}$ problem is defined as follows:
    \[\Pr[\adv(A,b) \to s \mid s \sample \mathbb{Z}_q^n, A \sample \mathbb{Z}_q^{m \times n}, b = A \cdot s + e ] \leq \negl\]
\end{definition}

\begin{definition}[Learning With Errors (Decision)]
    Let $m,n,q \in \mathbb{N}$ and $\chi$ be a distribution over $\mathbb{Z}_q$. The Learning With Errors (LWE) $\LWE_{n,m,q,\chi}$ problem is defined as follows:
    \begin{multline*}
        |\Pr[\adv(A,b) \to 1 \mid s \sample \mathbb{Z}_q^n, A \sample \mathbb{Z}_q^{m \times n}, b = A \cdot s + e ] \\
        - \Pr[\adv(A,b) \to 1 \mid s \sample \mathbb{Z}_q^n, A \sample \mathbb{Z}_q^{m \times n}, b \sample \mathbb{Z}_q^m ]|\leq \negl
    \end{multline*}
\end{definition}
The Learning With Errors assumption is commonly referred to as a Lattice based assumption because there is a reduction from Search/Decision LWE to a ``worst-case'' lattice problem.

The above assumptions have been stated with respect to some abstract distribution $\chi$ over $\mathbb{Z}_q$. But what do we actually choose this distribution to be? In the extreme case of $\chi = 0$, the LWE problem is trivial as one can simply use Gaussian Elimination. In the other extreme if $\chi$ is uniform over $\mathbb{Z}_q$, then the LWE problem is information theoretically hard (but not very useful for cryptography). We will be interested in the intermediate case where $\chi$ is a \emph{small} distribution over $\mathbb{Z}_q$, centered around 0. For eg: $\chi$ is a uniform distribution over $[-B, B]$ for some $B \ll q/2$. This will allow us to do build interesting cryptographic primitives like public key encryption and signature schemes. For provable reductions to lattice problems, we set $\mathsf{stddev}(\chi) = \Omega(\sqrt{n})$. However, there is a gap between the best known attacks on LWE and the best known reductions to lattice problems. As a result, much more aggressive parameters are used in practice, chosen based on the best known attacks. Typical parameters for LWE are $n = 512$, $q = 3329$, $\mathsf{supp}(\chi) = [-3,3]$, and $m = 768$. \cite{EPRINT:AlbPlaSco15} provides a lattice estimator \url{https://github.com/malb/lattice-estimator} that can be used to estimate the number of bits of security provided by a given set of LWE parameters.

\subsection{LWE $\to$ LWE-SKE}
As a first step, we will see how to build a symmetric key encryption scheme from LWE.

\begin{itemize}
    \item $\Gen$: Sample $s \sample \mathbb{Z}_q^n$ and output $\sk = s$.
    \item $\Enc(\sk,\mu)$: Sample $a \sample \mathbb{Z}_q^n$, $e \sample \chi$, and compute $b \gets \langle a, s \rangle + e$. Output $c = (c_0 = a, c_1 = b + \lfloor\frac{q}{2}\rfloor\mu)$.
    \item $\Dec(\sk,c)$: Parse $c = (c_0, c_1)$ and compute $m \gets \mathsf{Decode}(c_1 - \langle c_0, s \rangle)$, where $\mathsf{Decode}(\hat{\mu}) \to \{0,1\}$ takes a value from $\mathbb{Z}_q$ and outputs $0$ if $\hat{\mu} \in [\lfloor\frac{-q}{4}\rfloor, \lfloor\frac{q}{4}\rfloor]$ and $1$ otherwise.
\end{itemize}

\begin{theorem}
    If the decisional variant of $\LWE_{n,1,q,\chi}$ is hard, then the above scheme is an IND-CPA secure symmetric key encryption scheme.
\end{theorem}
\begin{proof}
    Let the ciphertext $c = (c_0, c_1)$. Then $\hat{\mu} = c_1 - \langle c_0,s\rangle = b + \lfloor\frac{q}{2}\rfloor - \langle a,s\rangle = \lfloor\frac{q}{2}\rfloor\mu + e$. Upon applying the $\mathsf{Decode}$ function, we recover the message $\mu$ if $|e| < \lfloor\frac{q}{4}\rfloor$.
    One can choose the noise distribution $\chi$ such that
    $\Pr[|e| \geq \lfloor\frac{q}{4}\rfloor] \leq \negl$, to obtain a symmetric key encryption scheme with a small correctness error. Alternatively, one can also set $\chi$ such that $\Pr[|e| \geq \lfloor\frac{q}{4}\rfloor] = 0$ to obtain a perfectly correct symmetric key encryption scheme.
    Security reduces to hardness of the decisional $\LWE_{n,1,q,\chi}$ problem.
\end{proof}

\subsection{How to build a public key encryption scheme from LWE?}
Our first observation is that LWE samples offer a limited amount of homomorphism. Given LWE samples $(a_1, b_1 = \langle a_1, s\rangle + e_1)$ and $(a_2, b_2 = \langle a_2, s\rangle + e_2)$, one can \emph{add} them up to get $(a_1 + a_2, b_1 + b_2 = \langle a_1 + a_2, s\rangle + (e_1+e_2))$. Observe that as long as $e_1 + e_2$ is small, we can still build useful cryptography as done in the symmetric key encryption scheme above.

Now to build public key encryption, we \emph{delegate} the power to create LWE samples, without revealing the secret $s$. We achieve this by setting the public key to be many symmetric key encryptions of $0$. The scheme below was originally proposed by Regev in 2005~\cite{STOC:Regev05}.

\begin{itemize}
    \item $\Gen$: Sample $s \sample \mathbb{Z}_q^n$, $A \sample \mathbb{Z}_q^{m \times n}$, $e \sample \chi^m$, $b \gets As + e$ and output $(\pk = (A,b), \sk = s)$.
    \item $\Enc(\pk, \mu)$: Sample $u \sample \{0,1\}^m$. Output $c = (c_0 = A^\intercal u,c_1 =  b^\intercal u + \lfloor\frac{q}{2}\rfloor\mu)$.
    \item $\Dec(\sk, c)$: Output $\mathsf{Decode}(c_1 - \langle c_0, s\rangle)$.
\end{itemize}

Observe that $b$ is actually just $m$ encryptions of $0$. Moreover, $m$ influences the size of the public key and we would like to make this as small as possible. The exact parameter will be chosen based on what we can actually prove security for.

\begin{proof}
    For correctness observe that as before $c_1 - \langle c_0, s\rangle = b^\intercal u + \lfloor\frac{q}{2}\rfloor\mu - \langle A^\intercal u, s\rangle = u^\intercal e + \lfloor\frac{q}.{2}\rfloor\mu$. $\mathsf{Decode}$ will recover $\mu$ if $|u^\intercal e| < \lfloor\frac{q}{4}\rfloor$, and one can choose $\chi$ to ensure this with high probability.

    For security, we describe a sequence of hybrids starting from the public-key IND-CPA game, where the challenger receives $(\mu_0, \mu_1)$, and responds with an encryption of $\mu_0$. We then end in a hybrid where the challenger responds with an encryption of $\mu_1$, while showing that consecutive hybrids are indistinguishable.

    \begin{itemize}
        \item \textbf{Hybrid 0}: This is the original public-key IND-CPA game, where the challenger samples $(\pk, \sk)$ as described in the protocol and receives $(\mu_0, \mu_1)$ from $\adv$. The challenger responds with an encryption of $\mu_0$ and $\adv$ outputs a guess $b'$.
        \item \textbf{Hybrid 1}: This hybrid is identical to Hybrid 0, except that the challenger sets $\pk = (A \sample \mathbb{Z}_q^{m \times n}, b \sample \mathbb{Z}_q^m)$. From the hardness of the decisional $\LWE_{n,m,q,\chi}$ problem, these two hybrids are computationally indistinguishable.
        \item \textbf{Hybrid 2}: In this hybrid we replace the ciphertext with a uniformly random string $c\in \mathbb{Z}_p^{n} \times \mathbb{Z}_p$. We now argue that this hybrid is statistically indistinguishable from the previous hybrid. Let $u \sample \{0,1\}^m$, and $\gamma \sample \mathbb{Z}_p^n$. Then $\mathbb{E}_{C \in \mathbb{Z}_q^{n \times m}}[\mathsf{SD}(C u, \gamma)] \leq \frac{1}{2} \sqrt{\frac{q^n}{2^m}}$. If we set $m = n \log{q} + 2\lambda$, then the statistical distance is negligible in the security parameter.

              To prove the above we will use the leftover hash lemma. Let $p_c(w) = \Pr_{u \sample \{0,1\}^m} [C u = w]$. Then,
              \[\sum_{w \in \mathbb{Z}_q^n} p_c(w)^2 = \Pr_{u_0, u_1 \sample \{0,1\}^m} [Cu_0 = Cu_1] = \frac{1}{2^m} + \mathbb{E}_C[\Pr_{u_0 \neq u_1}[C(u_0 - u_1) = 0]] = \frac{1}{2^m} + \frac{1}{q^n} \]

              Thus, $\mathbb{E}_{C \in \mathbb{Z}_q^{n \times m}}[\mathsf{SD}(C u, \gamma)] = \frac{1}{2}\mathbb{E}_{C}[\sum_w |p_c(w) - \frac{1}{q^n}|]\leq \frac{1}{2}\sqrt{q^n}\mathbb{E}_{C}\left[ \sqrt{\sum_w (p_c(w) - \frac{1}{q^n})^2} \right]$,
              where the inequality follows from Cauchy-Schwarz. Next, using Jensen's inequality we have
              \[ \frac{1}{2}\sqrt{q^n}\mathbb{E}_C\left[ \sqrt{\sum_w (p_c(w) - \frac{1}{q^n})^2}\right] \leq \frac{1}{2}\sqrt{q^n}\sqrt{\mathbb{E}_C \left[\sum_w (p_c(w)^2 - \frac{1}{q^n})\right] } = \frac{1}{2}\sqrt{\frac{q^n}{2^m}}\]
    \end{itemize}
    The remaining hybrids are symmetric to end in the IND-CPA game with challenge response set to an encryption of $\mu_1$.
\end{proof}
\subsection{Improving Efficiency}
It is worthwhile asking whether the parameter $m$ can be made smaller. Recall that when using the leftover hash lemma we needed to set $m = n\log{q} + 2\lambda$ but we got a statistical guarantee of indistinguishability. This \emph{overkill} in some sense because we still rely on the LWE assumption in a different hybrid. We can then ask the question of whether it's possible to improve efficiency and obtain \emph{compact} LWE public-key encryption if we relied on computational hardness instead of a statistical guarantee.

This was the approach taken in~\cite{RSA:LinPei11}, where they used the hardness of LWE instead of the leftover hash lemma to switch ciphertexts to uniformly random strings in the proof of IND-CPA security. The scheme is essentially identical to the previous construction except, the secret key is also sampled from the error distribution instead of uniformly over the entire field. This is necessary for correctness. But we are no longer working with LWE samples as the secret key is no longer uniform. These new type of instance are referred to as Hermite normal form LWE instances. We will later show that distinguishing HNF-LWE samples from a uniform distribution is just as hard distinguishing LWE samples from the uniform distribution.

\begin{definition}[HNF-LWE]
    Let $m,n,q \in \mathbb{N}$ and $\chi$ be a distribution over $\mathbb{Z}_q$. The Learning With Errors (LWE) $\LWE_{n,m,q,\chi}$ problem is defined as follows:
    \begin{multline*}
        |\Pr[\adv(A,b) \to 1 \mid s \sample \chi_q^n, A \sample \mathbb{Z}_q^{m \times n}, b = A \cdot s + e ] \\
        - \Pr[\adv(A,b) \to 1 \mid A \sample \mathbb{Z}_q^{m \times n}, b \sample \mathbb{Z}_q^m ]|\leq \negl
    \end{multline*}
\end{definition}

\begin{lemma}[$\LWE_{n,q,\chi,m} \leq \mathsf{HNF-LWE}_{n,q,\chi,m-n}$]
\end{lemma}
\begin{proof}
    Parse $A$ and $b$ as:
    \[A:\begin{bmatrix} A_1 \\ A_2 \end{bmatrix} \quad b:\begin{bmatrix} b_1 \\ b_2 \end{bmatrix} = \begin{bmatrix} A_1 s + e_1 \\ A_2 s + e_2 \end{bmatrix}\]
    and bbort if $A_1$ is not invertible. This happens with probability $\le 0.91$. Next, provide
    \[\begin{pmatrix} \tilde{A} := A_2 \cdot A_1^{-1} \\ \tilde{b} := -A_2 \cdot A_1^{-1} \cdot b_1 + b_2 \end{pmatrix}\] to the HNF-LWE solver. Note that $\tilde{b}$ simplifies to
    \begin{equation*}
        \begin{aligned}
            \tilde{b} & = A_2 A_1^{-1} (A_1 s + e_1) + A_2 s + e_2 \\
                      & = A_2 s - A_2 A_1^{-1} e_1 + A_2 s + e_2   \\
                      & = A_2 e_1 + e_2                            \\
        \end{aligned}
    \end{equation*}
    which is actually an HNF-LWE sample. Hence, if the HNF-LWE solver succeeds with non-negligible probability, then the LWE solver also succeeds with non-negligible probability.
\end{proof}

\begin{construction}[Compact LWE-PKE \citep{RSA:LinPei11}]
    \hfill
    \begin{itemize}
        \item $\Gen$: Sample $s \sample \chi_q^n$, $A \sample \mathbb{Z}_q^{n \times n}$, $e \sample \chi^n$, $b \gets As + e$ and output $(\pk = (A,b), \sk = s)$.
        \item $\Enc(\pk, \mu)$: Sample $u \sample \mathbb{Z}_q^n$, $e_0 \sample \chi^n$ and $e_1 \sample \chi$. Output $c = (c_0 = A^\intercal u + e_0,c_1 =  b^\intercal u + e_1 + \lfloor\frac{q}{2}\rfloor\mu)$.
        \item $\Dec(\sk, c)$: Output $\mathsf{Decode}(c_1 - \langle c_0, s\rangle)$.
    \end{itemize}
\end{construction}

The proof of security follows a similar strategy as earlier, except when replacing the ciphertext with a uniformly random string, we use the hardness of HNF-LWE.

% Stuff from Lec 16 
\subsection{Ring-LWE}
From the same motivation as above, we would like to improve the efficiency of our scheme by decreasing the number of random elements we sample (to get the matrix $A$). Note that the methods we used above require sampling $O(n^2)$ random elements to form the random matrix. 
\begin{itemize}
    \item Instead, we could replace $A$ with a structured (cyclic) matrix where each row is a cyclic shift of the previous row. This only requires $O(n)$ random elements to be sampled. However, this turns out to not be secure. \\
    Assuming that $q = 1 \mod n$, we can write this in polynomial form as $a(x) \cdot s(x) + e(x) = b(x) \mod (x^n - 1)$. The assumption on $q$ is made so that number theoretic transforms can be used to efficiently multiply polynomials. Since $x^n - 1$ is divisible by $x-1$, we have the additional relation $a(1) \cdot s(1) + e(1) = b(1)$ where both $s(1)$ and $e(1)$ are small. This allows us to construct a distinguisher.

    \item To prevent this, we would like to choose a irreducible polynomial instead, say, $x^n + 1$. Using negacyclic matrices instead (and $q = 1 \mod 2n$), we get a similar relation $a(x) \cdot s(x) + e(x) = b(x) \mod (x^n + 1)$. However, this does not have the same issue as before. This forms the basis of the Ring-LWE assumption. Other cyclotomic polynomials can also be used and we work in the ring $\mathbb{Z}_q[x]/<x^n + 1>$. \\
    This construction was shown to be secure in \cite{EC:LyuPeiReg10}.
\end{itemize}

\begin{definition}[HNF-RLWE]
    Let $n$ be the ring dimension, $q$ be the modulus, and $\chi$ be a distribution over $R_q$ where $R_q = \mathbb{Z}_q[x]/<x^n + 1>$. The HNF-RLWE problem is defined as follows:  
    \begin{align*}
        a(x) &\getsr R_q \\
        s(x) &\getsr \chi \\
        e(x) &\getsr \chi \\
        b(x) &\gets a(x) \cdot s(x) + e(x) \\
        \text{Distinguish } (a(x), b(x)) &\text{ from } (a(x), b'(x)) \text{ where } b'(x) \getsr R_q 
    \end{align*}
\end{definition}
\begin{itemize}
    \item RLWE has similar worst-case to average-case reductions to hard lattice problems as LWE. However, these hard problems are on "ideal lattices" which are structured lattices. 
    $$\text{Worst-case ``ideal lattice'' problems} \leq \text{Search RLWE} \leq \text{Decision RLWE}$$

    \item $\text{RLWE} \leq \text{HNF-RLWE}$
    \item On the plus side, state of the art attacks on RLWE do not exploit the ring structure and instead treat it as a LWE instance.
\end{itemize}

We can also build a public-key encryption scheme from RLWE, similar to the compact LWE-PKE scheme. The security proof is also similar.
\begin{construction}[RLWE-PKE]
    \hfill
    \begin{itemize}
        \item $\Gen$: Sample $s(x) \sample \chi_q$, $a(x) \sample R_q$, $e(x) \sample \chi$, $b(x) \gets a(x) \cdot s(x) + e(x)$ and output $(\pk = (a(x),b(x)), \sk = s(x))$.
        \item $\Enc(\pk, \mu)$: Sample $u(x) \sample R_q$, $e_0(x) \sample \chi$ and $e_1(x) \sample \chi$. Output $c = (c_0 = a(x) \cdot u(x) + e_0(x),c_1 =  b(x) \cdot u(x) + e_1(x) + \lfloor\frac{q}{2}\rfloor\mu)$.
        \item $\Dec(\sk, (c_0,c_1))$: Output $\mathsf{Decode}(c_1(x) - c_0(x) \cdot s(x))$.
    \end{itemize}
\end{construction}

\begin{table}[!htbp]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        & LWE & RLWE \\
        \hline
        Public Key Size & $(n^2 + n) \log q$ & $2n \log q$ \\
        \hline
        Ciphertext Size & $(n+1) \log q$ & $2n \log q$ \\
        \hline
        Message Length & $1$ & $n$ \\
        \hline
        Computation Cost & $O(n^2)$ & $\tilde{O}(n)$ \\
        \hline
    \end{tabular}
    \caption{Comparison of LWE and RLWE}
\end{table}

\subsection{Module LWE}
\cite{ITCS:BraGenVai12}, along with the first implementable FHE scheme, introduced the Module-LWE assumption. This is a generalization of LWE and RLWE, and was initially created for notational purposes to avoid having to write two different definitions. Setting parameters to certain values returns LWE or RLWE. However, there are middle cases that are not covered by LWE or RLWE. 

The Module-LWE assumption is defined as follows:
\begin{definition}[Module-LWE]
    Let $n$ be the degree, $q$ be the modulus, and $\chi$ be a distribution over $R_q$. Additionally, let $m$ be the number of samples and $k$ be the dimension.
    The Module-LWE problem is defined as follows: 
    \begin{align*}
        A &\getsr R_q^{m \times k} \\
        s &\getsr \chi^k \\
        e &\getsr \chi^m \\
        b &\gets A \cdot s + e \\
        \text{Distinguish } (A,b) &\text{ from } (A,b') \text{ where } b' \getsr R_q^m
    \end{align*}
\end{definition}

Note that this is the same as LWE when $k = 1$ and RLWE when $n = 1$. 

\begin{itemize}
    \item $\text{Worst-case ``rank-k" lattice problems} \leq \text{Search Module-LWE} \leq \text{Decision Module-LWE}$
    \item $\text{Module-LWE} \leq \text{HNF-Module-LWE}$ ~\cite{DCC:LanSte15}
    \item Why use MLWE? - Efficiency and Flexibility.
    \begin{itemize}
        \item Powers of two are sparse, we would need to jump from $n=512$ to $n=1024$ for instance.
        \item New Hope is another NIST candidate based on RLWE. It has parameters $n=1024$, $q=12289$ while Kyber has $n=256$, $q=3329$. The ring LWE condition requires $q = 1 \mod 2n$, and hence the larger $q$. 
    \end{itemize}
    \item Other engineering considerations for Kyber:
    \begin{itemize}
        \item The Fujisaki-Okamoto transform is used to obtain CCA security.
        \item Note that Kyber's prime does not satisfy $q = 1 \mod 2n$, and they only get incomplete NTT speedups.
        \item The matrix $A$ can be compressed using a random oracle or hash.
        \item The error distribution is restricted to $[-3,3]$. In addition, for easier sampling, instead of using a uniform distribution, they use a centered binomial distribution (sampling from this only requires sampling some bits and adding them).
        \item Another optimization for proof size is to drop the last bit of the ciphertext.
    \end{itemize}
    \item Finally, Kyber gets a public key size of $800$ bytes, a ciphertext size of $768$ bytes, and decryption failure probability of $2^{-139}$.
\end{itemize} 
\section{Cramer-Shoup Construction}

The Cramer-Shoup cryptosystem is a public-key encryption scheme that achieves security against adaptive chosen ciphertext attacks (CCA2). To understand its significance, let's first examine the ElGamal encryption scheme and its limitations.

\subsection{Background: ElGamal Encryption}

ElGamal encryption is a simple and elegant public-key system based on the Diffie-Hellman key exchange. The scheme operates as follows:

\begin{itemize}
    \item $\textsc{Gen}(1^n)$:
        \begin{algorithmic}
            \State Select prime $q$ where $|q|=n$
            \State Choose generator $g$ of group $G$ of order $q$
            \State Sample $x \gets \mathbb{Z}_q$ randomly
            \State Compute $h = g^x$
            \State Output $(\mathrm{pk}=(g,h), \mathrm{sk}=x)$
        \end{algorithmic}
    
    \item $\textsc{Enc}(\mathrm{pk}, m \in G)$:
        \begin{algorithmic}
            \State Sample $r \gets \mathbb{Z}_q$ randomly
            \State Compute $c_1 = g^r$
            \State Compute $c_2 = m \cdot h^r$
            \State Output $(c_1, c_2)$
        \end{algorithmic}

    \item $\textsc{Dec}(\mathrm{sk}, (c_1, c_2))$:
        \begin{algorithmic}
            \State Compute $m = c_2/c_1^x$
            \State Output $m$
        \end{algorithmic}
\end{itemize}

\textbf{Proof of Correctness:}
\begin{align*}
    c_2/c_1^x &= (m \cdot h^r)/(g^r)^x \\
    &= (m \cdot (g^x)^r)/(g^r)^x \\
    &= m \cdot g^{xr}/g^{rx} \\
    &= m
\end{align*}

However, ElGamal is malleable, meaning an adversary can modify a ciphertext to create a related ciphertext. Given a ciphertext $(c_1, c_2)$ encrypting message $m$, an adversary can create $(c_1, k \cdot c_2)$ which will decrypt to $k \cdot m$ for any $k$. This malleability makes ElGamal insecure against chosen-ciphertext attacks.

\subsection{Hash Proof Systems}

To address these limitations, we introduce Hash Proof Systems (HPS), a powerful tool for constructing CCA-secure encryption schemes.

\subsection{Formal Definition}

Let $\mathbb{X}$ be a set and $\mathbb{L} \subset \mathbb{X}$ be a language defined by:
\[ \mathbb{L} = \{x \in \mathbb{X} \mid \exists w \text{ s.t. } (x,w) \in \mathbb{R}\} \]
where $\mathbb{R}$ is a binary relation and $w$ is called a witness.

A Hash Proof System consists of three algorithms:
\begin{itemize}
    \item $\mathcal{K}\mathcal{G}\text{en}(1^n)$: Generates key pair $(pk, sk)$
    \item $\mathcal{H}_{sk}: \mathbb{X} \rightarrow \Pi$ (private evaluation)
    \item $\mathcal{H}_{pk}: \mathbb{L} \times \mathbb{W} \rightarrow \Pi$ (public evaluation)
\end{itemize}

\subsection{Key Properties}

\begin{enumerate}
    \item \textbf{Correctness:} For all $(x,w) \in \mathbb{R}$:
    \[ \mathcal{H}_{sk}(x) = \mathcal{H}_{pk}(x,w) \]
    
    \textbf{Proof:}
    This follows from the construction where both evaluations compute the same mathematical operation, but $\mathcal{H}_{pk}$ requires a witness while $\mathcal{H}_{sk}$ uses the secret key.

    \item \textbf{Smoothness:} For all $x \not\in \mathbb{L}$:
    \[ \{pk, \mathcal{H}_{sk}(x)\} \stackrel{s}{\approx} \{pk, U_\Pi\} \]
    where $U_\Pi$ is uniform over $\Pi$.
    
    \textbf{Proof Sketch:}
    This property follows from the DDH assumption in our concrete construction. When $x \not\in \mathbb{L}$, the hash value appears random to any computationally bounded adversary.

    \item \textbf{Universal Property:} For all $x \in \mathbb{L}$ and $y_1, \ldots y_t \in \mathbb{L}$:
    \[ \{pk, \mathcal{H}_{sk}(x), \{\mathcal{H}_{pk}(y_i)\}_i\} \stackrel{s}{\approx} \{pk, U_\Pi, \{\mathcal{H}_{sk}(y_i)\}_i\} \]
\end{enumerate}

\subsection{Concrete DDH-based Construction}

Let's construct a specific HPS based on the Decision Diffie-Hellman (DDH) assumption:

\begin{itemize}
    \item Let $G$ be a cyclic group of prime order $q$
    \item Fix generators $g_1, g_2 \in G$
    \item Define $\mathbb{X} = G^2$
    \item Define $\mathbb{L} = \{(h_1,h_2) \in \mathbb{X} \mid \exists r \in \mathbb{Z}_q: h_1=g_1^r \text{ and } h_2=g_2^r\}$
\end{itemize}

The construction:
\begin{align*}
    \mathcal{K}\mathcal{G}\text{en}(1^n): &\text{ Sample } d_1,d_2 \gets \mathbb{Z}_q \\
    &\text{ Output } (pk=(g_1^{d_1}g_2^{d_2}), sk=(d_1,d_2)) \\
    \mathcal{H}_{sk}(x=(h_1,h_2)) &= h_1^{d_1}h_2^{d_2} \\
    \mathcal{H}_{pk}(x=(h_1,h_2),w=r) &= pk^r
\end{align*}

\textbf{Proof of Correctness:}
For $(x,w) \in \mathbb{R}$ where $x=(g_1^r, g_2^r)$:
\begin{align*}
    \mathcal{H}_{sk}(x) &= (g_1^r)^{d_1}(g_2^r)^{d_2} \\
    &= g_1^{rd_1}g_2^{rd_2} \\
    &= (g_1^{d_1}g_2^{d_2})^r \\
    &= pk^r \\
    &= \mathcal{H}_{pk}(x,w)
\end{align*}

\subsection{Basic Scheme and Its Limitations}

Let's analyze our first attempt at constructing a secure encryption scheme using HPS:

$\mathcal{G}\text{en}(1^n)$:
\begin{itemize}
    \item $(pk,sk) \leftarrow \mathcal{K}\mathcal{G}\text{en}(1^n)$
\end{itemize}

$\text{Enc}(pk,m \in G)$:
\begin{enumerate}
    \item Sample $x \leftarrow \mathbb{L}$ along with witness $w$
    \item Compute $e = \mathcal{H}_{pk}(x,w) \cdot m$
    \item Output $(x,e)$
\end{enumerate}

$\text{Dec}(sk,(x,e))$:
\begin{itemize}
    \item Output $e/\mathcal{H}_{sk}(x)$
\end{itemize}

\subsection{Security Analysis of Basic Scheme}

While this construction achieves CPA security through the following hybrid argument:

\begin{enumerate}
    \item $\mathcal{H}_0$: Real encryption game
    \item $\mathcal{H}_1$: Replace $e = \mathcal{H}_{sk}(x) \cdot m$ (using $sk$ instead of $pk$)
        \begin{itemize}
            \item This is identical to $\mathcal{H}_0$ because $x \in \mathbb{L}$ and by HPS correctness
            \item Formally: For any $(x,w) \in \mathbb{R}$, $\mathcal{H}_{pk}(x,w) = \mathcal{H}_{sk}(x)$
        \end{itemize}
    \item $\mathcal{H}_2$: Replace $x \leftarrow \mathbb{X} \setminus \mathbb{L}$ 
        \begin{itemize}
            \item Indistinguishable by property 2 of HPS
            \item Adversary cannot tell if $x$ is sampled from $\mathbb{L}$ or $\mathbb{X} \setminus \mathbb{L}$
        \end{itemize}
    \item $\mathcal{H}_3$: Replace $e$ with uniform random element
        \begin{itemize}
            \item Indistinguishable by smoothness property of HPS
            \item When $x \not\in \mathbb{L}$, $\mathcal{H}_{sk}(x)$ is statistically close to uniform
        \end{itemize}
\end{enumerate}

However, this scheme fails to achieve CCA-2 security. Here's a concrete attack:

\begin{theorem}[CCA-2 Attack on Basic Scheme]
The basic HPS construction is not CCA-2 secure.
\end{theorem}

\begin{proof}
Consider the following attack in the CCA-2 game:
\begin{enumerate}
    \item Adversary receives challenge ciphertext $(x^*, e^*)$ for message $m_b$
    \item Adversary creates modified ciphertext $(x^*, k \cdot e^*)$ for some $k \in G$
    \item Adversary submits modified ciphertext to decryption oracle
    \item Let $m'$ be the decrypted result. Then:
    \begin{align*}
        m' &= (k \cdot e^*)/\mathcal{H}_{sk}(x^*) \\
        &= k \cdot (e^*/\mathcal{H}_{sk}(x^*)) \\
        &= k \cdot m_b
    \end{align*}
    \item Since $k$ is known, adversary can recover $m_b$ and win the CCA-2 game
\end{enumerate}
\end{proof}

\subsection{The Need for Ciphertext Integrity}

The key insight is that we need to prevent ciphertext manipulation. The full Cramer-Shoup construction addresses this by:

\begin{enumerate}
    \item Adding a second HPS instance ($\mathcal{H}'$) that acts as a "proof of well-formedness"
    \item Using a collision-resistant hash function to bind all components together
    \item Verifying the proof $\pi$ before decryption
\end{enumerate}

The second HPS instance must satisfy a stronger security property called "2-smoothness":

\begin{definition}[2-Smoothness]
For all $x_1,x_2 \in \mathbb{L}$ and $t_1,t_2 \in T$ with $t_1 \neq t_2$:
\[ \{pk, \mathcal{H}_{sk}(x_1,t_1), \mathcal{H}_{sk}(x_2,t_2)\} \stackrel{s}{\approx} \{pk, U_\Pi, U_\Pi\} \]
\end{definition}

\subsection{CCA-2 Secure Construction}

The final Cramer-Shoup construction achieves CCA-2 security by combining two HPS instances with a collision-resistant hash function:

\subsection{The Scheme}

$\mathcal{G}\text{en}(1^n)$:
\begin{algorithmic}
    \State $(pk,sk) \leftarrow \mathcal{K}\mathcal{G}\text{en}(1^n)$
    \State $(pk',sk') \leftarrow \mathcal{K}\mathcal{G}\text{en}(1^n)$
    \State Output $((pk,pk'),(sk,sk'))$
\end{algorithmic}

$\text{Enc}(pk,m)$:
\begin{algorithmic}
    \State Sample $x \leftarrow \mathbb{L}$ with witness $w$
    \State $e = \mathcal{H}_{pk}(x,w) \cdot m$
    \State $t = \text{CRHF}(x,e)$
    \State $\pi = \mathcal{H}'_{pk}(x,w,t)$
    \State Output $(x,e,\pi)$
\end{algorithmic}

$\text{Dec}(sk,(x,e,\pi))$:
\begin{algorithmic}
    \If{$\pi \neq \mathcal{H}'_{sk}(x)$}
        \State Output $\perp$
    \EndIf
    \State Output $e/\mathcal{H}_{sk}(x)$
\end{algorithmic}
\subsection{Final Security Theorem}

\begin{theorem}
If $\mathcal{H}$ is a 1-smooth HPS, $\mathcal{H}'$ is a 2-smooth HPS, and CRHF is a collision-resistant hash function, then the scheme is CCA-2 secure.
\end{theorem}

\begin{proof}
We prove security through a sequence of hybrid games, showing each transition is indistinguishable to a PPT adversary. Let $A$ be any PPT adversary in the CCA2 game.

First, we establish a crucial lemma:

\begin{lemma}[Key Soundness Lemma]
For any ciphertext decryption query $(x,e,\pi)$ that $A$ makes, if $\text{Dec}((sk,sk'),(x,e,\pi)) \neq \perp$ then $x \in \mathbb{L}$ except with negligible probability.
\end{lemma}

\begin{proof}[Proof of Lemma]
Suppose for contradiction that $x \notin \mathbb{L}$ but the decryption doesn't return $\perp$. This means:
\[ \pi = \mathcal{H}'_{sk'}(x, \text{CRHF}(x,e)) \]

By the 2-smoothness property of $\mathcal{H}'$, when $x \notin \mathbb{L}$, the value $\mathcal{H}'_{sk'}(x,t)$ is statistically indistinguishable from random, even given $pk'$. Therefore, the probability that $A$ can generate such a $\pi$ is at most $1/|\Pi|$, which is negligible.
\end{proof}

Now we proceed with the hybrid games:

\begin{itemize}
    \item $\mathcal{G}_0$: The real CCA2 game.
    
    \item $\mathcal{G}_1$: Same as $\mathcal{G}_0$, but the challenger computes the challenge ciphertext's $e^*$ component using $sk$ instead of $pk$:
    \[ e^* = \mathcal{H}_{sk}(x^*) \cdot m_b \]
    instead of
    \[ e^* = \mathcal{H}_{pk}(x^*,w) \cdot m_b \]
    
    By the correctness property of HPS, these are identical when $x^* \in \mathbb{L}$, so:
    \[ \Pr[\mathcal{G}_0 = 1] = \Pr[\mathcal{G}_1 = 1] \]

    \item $\mathcal{G}_2$: Same as $\mathcal{G}_1$, but now the challenger samples $x^* \gets \mathbb{X} \setminus \mathbb{L}$ instead of from $\mathbb{L}$.
    
    By the hardness of distinguishing elements in $\mathbb{L}$ from elements in $\mathbb{X} \setminus \mathbb{L}$ (which follows from the DDH assumption in our concrete construction):
    \[ |\Pr[\mathcal{G}_1 = 1] - \Pr[\mathcal{G}_2 = 1]| \leq \epsilon_{\text{DDH}} \]

    \item $\mathcal{G}_3$: Same as $\mathcal{G}_2$, but replace $\mathcal{H}_{sk}(x^*)$ with a uniform random value $u \gets \Pi$ in computing $e^*$:
    \[ e^* = u \cdot m_b \]
    
    By the smoothness property of $\mathcal{H}$, since $x^* \notin \mathbb{L}$:
    \[ |\Pr[\mathcal{G}_2 = 1] - \Pr[\mathcal{G}_3 = 1]| \leq \epsilon_{\text{smooth}} \]

    \item $\mathcal{G}_4$: Same as $\mathcal{G}_3$, but replace $e^*$ with a uniform random value in $G$. 
    
    Since $u$ is uniform in $\Pi$ and independent of $m_b$, $e^*$ is uniform in $G$ and independent of $m_b$, so:
    \[ \Pr[\mathcal{G}_3 = 1] = \Pr[\mathcal{G}_4 = 1] \]
\end{itemize}

In $\mathcal{G}_4$, the challenge ciphertext is independent of $m_b$, so $A$ has no advantage. Therefore:
\[ \text{Adv}^{\text{CCA2}}_A \leq \epsilon_{\text{DDH}} + \epsilon_{\text{smooth}} \]

To complete the proof, we need to show that the decryption oracle queries in all games can be answered properly. For any decryption query $(x,e,\pi)$:

\begin{enumerate}
    \item If $(x,e) = (x^*,e^*)$ but $\pi \neq \pi^*$: By 2-smoothness of $\mathcal{H}'$, generating a valid $\pi$ is infeasible.
    \item If $(x,e) \neq (x^*,e^*)$ but $\text{CRHF}(x,e) = \text{CRHF}(x^*,e^*)$: This breaks collision resistance of CRHF.
    \item If $\text{CRHF}(x,e) \neq \text{CRHF}(x^*,e^*)$: By 2-smoothness of $\mathcal{H}'$, any $\pi$ that verifies must correspond to a witness $w$ such that $(x,w) \in \mathbb{R}$, meaning $x \in \mathbb{L}$. Therefore, the decryption oracle can be simulated properly.
\end{enumerate}

Thus, all hybrid games are indistinguishable to $A$, and the scheme is CCA2-secure.
\end{proof}


