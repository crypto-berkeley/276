\chapter{Chapter 7}
\label{chap:7}

\\chapter{Advanced Encryption Schemes}
\\section{Identity-Based Encryption}

We introduce Bilinear Maps and two of its applications: NIKE, Non-Interactive Key Exchange; and IBE, Identity Based Encryption.


\\section{Diffie-Hellman Key Exchange}

\\begin{figure}
\\label{fig:dh}
\\centering
  \\includegraphics[width=0.7\\textwidth]{figures/fig1.pdf}
\\caption{Diffie-Hellman Key Exchange}
\\end{figure}


Fig \\ref{fig:dh} illustrates Diffie-Hellman key exchange. Alice and Bob each has a private key (\$a\$ and \$b\$ respectively), and they want to build a shared key for symmetric encryption communication. They can only communicate over a insecure link, which is eavesdropped by Eve.
So Alice generates a public key \$A\$ and Bob generates a public key \$B\$, and they send their public key to each other at the same time. Then Alice generates the shared key \$K\$ from \$a\$ and \$B\$, and likewise, Bob generates the shared key \$K\$ from \$b\$ and \$A\$.
And we have \$\\forall\$ PPT Eve, \$Pr[k=Eve(A,B)]=neg(k)\$, where \$k\$ is the length of \$a\$.


\\subsection{Discussion 1}

Assume that \$\\forall (g, p)\$, and \$a_1,b_1 \\stackrel{\\\$}{\\gets} Z^*_p\$, and \$a_2,b_2,r \\stackrel{\\\$}{\\gets}Z^*_p\$, we have \$(g^{a_1}, g^{b_1}, g^{a_1b_1}) \\stackrel{c}{\\simeq} (g^{a_2}, g^{b_2}, g^r)\$. How to apply this to Diffie-Hellman Key Exchange?


Make \$A=g^a\$, \$B=g^b\$, \$K=A^b=g^{ab}\$, and \$K=B^a=g^{ab}\$.


\\subsection{Discussion 2}


How does Diffie-Hellman Key Exchange imply Public Key Encryption?


Alice
\$pk = A\$, \$sk = a\$, \$Enc(pk, m \\in \\{0, 1\\})\$.

Bob
\$b,r \\gets Z^*_p\$
\$(g^b, mA^b+(1-m)g^r)\$

Alice \$Dec(sk, (c_1, c_2))\$

\$c_1^a \\stackrel{?}{=} c_2\$




\\section{Bilinear Maps}

\\begin{definition}{Bilinear Maps}

Bilinear Maps is \$(G,P,G_T,g,e)\$, where \$e\$ is an efficient function \$G \\times G \\to G_T\$ such that

\\begin{itemize}
\\item if \$g\$ is generator of \$G\$, then \$e(g, g)\$ is the generator of \$G_T\$.
\\item \$\\forall a,b \\in Z_p\$, we have \$e(g^a, g^b) = e(g, g)^{ab} = e(g^b, g^a)\$.
\\end{itemize}

\\end{definition}

\\subsection{Discussion 1}


How does Bilinear Maps apply to Diffie-Hellman?

Make \$A=g^a\$, \$B=g^b\$, and \$T=g^{ab}\$, then Diffie-Hellman has \$e(A, B)=e(g, T)\$.


\\section{Tripartite Diffie-Hellman}

\\begin{figure}
\\label{fig:3dh}
\\centering
  \\includegraphics[width=0.7\\textwidth]{figures/fig2.pdf}
\\caption{Tripartite Diffie-Hellman Key Exchange}
\\end{figure}

Fig \\ref{fig:3dh} illustrates Tripartite Diffie-Hellman key exchange. \$a\$, \$b\$, and \$c\$ are private key of Alice, Bob, and Carol, respectively.
They use \$g^a\$, \$g^b\$, \$g^c\$ as public key, and the shared key \$K=e(g,g)^{abc}\$.
Formally, we have
\$\$a,b,c \\stackrel{\\\$}{\\gets} Z^*_p, r \\stackrel{\\\$}{\\gets} Z^*_p\$\$
\$\$A=g^a, B=g^b, C=g^c\$\$
\$\$K=e(g,g)^{abc}\$\$



\\section{IBE: Identity-Based Encryption}
When two parties communicate secure messages through a public key infrastructure, they need to go through a time-consuming and error-prone process to get each other's key and verify each other's identity through a Certificate Authority. 
Identity-based cryptography (IBC) seeks to reduce these barriers by requiring no preparation on the part of the message recipient, therefore saving the initial round trip. 
Identity based encryption can also be used to construct CCA-secure public key encryption and digital signatures. 

IBE contains four steps: \\emph{Setup}, \\emph{KeyGen}, \\emph{Enc}, and \\emph{Dec}. We illustrate it in Figure \\ref{fig:ibe}.
IBE relies on a trusted third party called Private Key Generator(PKG). 
In first step, PKG gets a Master Public Key (\$mpk\$) and Master Signing Key (\$msk\$) from \$Gen(1^n)\$. 
Then a user with an ID (in this example, ``Mike''), sends his ID to the PKG. 
The PKG generates the Signing Key of Mike with \$KeyGen(msk, id)\$ ans sends it back. 
Another user, Alice, wants to send an encrypted message to Mike. 
She only has \$mpk\$ and Mike's ID. 
So she encrypts the message with \$c=Enc(mpk, id=Mike, m)\$, and sends the encrypted message \$c\$ to Mike. 
Mike decodes \$c\$ with \$m=Dec(c, sk_{Mike})\$. 
Notice that Alice never need to know Mike's public key. 
She only needs to remember MPK and other people's IDs.

\\begin{figure}
\\label{fig:ibe}
\\centering
  \\includegraphics[width=0.7\\textwidth]{figures/fig3.pdf}
\\caption{Identity-Based Encryption}
\\end{figure}

Then we define IBE formally, 

\\begin{definition}[Identity-Based Encryption]
    An \\textbf{identity based encryption scheme} \$\\mathcal{E}_{id} = (G,K,E,D)\$ is a tuple of four efficient algorithms: a \\textbf{setup algorithm} \$G\$, a \\textbf{key generation algorithm} \$K\$, an \\textbf{encryption algorithm} \$E\$, and a \\textbf{decryption algorithm} \$D\$.
    \\begin{itemize}
        \\item \$G\$ is a probabilistic algorithm invoked as \$(mpk, msk)\\stackrel{\\\$}{\\gets} G(1^n)\$, where \$mpk\$ is called the \\textbf{master public key} and \$msk\$ is called the \\textbf{master secret key} for the IBE scheme.
        \\item \$K\$ is a probabilistic algorithm invoked as \$sk_{id}\\stackrel{\\\$}{\\gets}K(msk,id )\$, where \$msk\$ is the master secret key (as output by \$S\$), \$id \\in \\mathcal{ID}\$ is an identity, and \$sk_{id}\$ is a secret key for id.
        \\item \$E\$ is a probabilistic algorithm invoked as \$c\\stackrel{\\\$}{\\gets}E(mpk,id, m)\$.
        \\item \$D\$ is a deterministic algorithm invoked as \$m\\gets D(sk_{id}, c)\$. Here \$m\$ is either a message or a special reject value \$\\bot\$ (distinct from all messages).
    \\end{itemize}
\\end{definition}

As usual, we define the correctness of IBE to be the decryption undoes encryption, formally we have 
\\begin{definition}[Correctness of IBE]
\$\\forall n, id, m\$, we have
\\[
Pr\\begin{bmatrix}
   (mpk,msk) \\gets G(1^n), \\\\[0.3em]
   sk_{id} \\gets K(msk, ID), \\\\[0.3em]
   c \\gets E(mpk, id, m), \\\\[0.3em]
   m \\gets D(sk_{id}, c)
\\end{bmatrix}
  =1 - \\text{negl}(n)
\\]
\\end{definition}

Next we define the security of IBE scheme. 
The basic security definition considers an adversary who obtains the secret keys for a number of identities of its choice. 
The adversary should not be able to break semantic security for some other identity of its choice for which it does not have the secret key.

\\begin{definition}[Security of IBE]
    For an IBE scheme \$\\mathcal{E}_{id}=(G,K,E,D)\$ is secure if \$\\forall\$ nuPPT \$\\mathcal{A}\$,
    \\[
    \\Pr[\\text{Exp}_{\\pi,\\mathcal{A}}^{IBE,CPA}(n)=1]=\\text{negl}(n)
    \\]
\\end{definition}

We then define the experiment \$\\text{Exp}_{\\pi,\\mathcal{A}}^{IBE,CPA}\$.
\\begin{definition}[IBE-CPA Experiment]
We denote the experiment in the following order: 
\\begin{enumerate}
    \\item The challenger invokes \$(mpk, msk)\\stackrel{\\\$}{\\gets} G(1^n)\$ and send \$mpk\$ to adversary \$\\mathcal{A}\$.
    \\item \$\\mathcal{A}\$ can make multiple key queries and generate desired ID \$id^{*}\$ and two message \$(m_0, m_1)\$. 
    \\item Challenger random selects \$b\\stackrel{\\\$}{\\gets}\\{0,1\\}\$ and encrypt \$c^{*}=E(mpk, id^{*},m_b)\$ and send \$c^{*}\$ to \$\\mathcal{A}\$.
    \\item \$\\mathcal{A}\$ can make more encryption queries based on \$c^{*}\$ and other id and message \$(m_0,m_1)\$. Note that throughout the process \$\\mathcal{A}\$ can \\textbf{never} make any query on \$id^{*}\$. 
    \\item At the end, \$\\mathcal{A}\$ generate \$b'\$ and send to challenger. 
    \\item Challenger output \$1\$ if \$b=b'\$, \$0\$ otherwise. 
\\end{enumerate}
\\end{definition}

\\subsection{IBE Construction from Pairing}
We then present a concrete IBE construction from pairing.
First, we will give the hardness assumption in this scheme called \\textbf{bilinear Diffe-Hellman} assumption, or BDH. 
This assumption says that given random element \$g_0^{\\alpha},g_0^{\\beta},g_0^{\\gamma}\\in\\mathbb{G_0}\$ and a few additional terms, the quantity \$e(g0,g1)^{\\alpha\\beta\\gamma}\\in\\mathbb{G}_T\$ is computationally indistinguishable from a random element in GT.

\\begin{definition}[Decisional bilinear Diffe-Hellman]
    Let \$e: \\mathbb{G}_0\\times\\mathbb{G}_1\\rightarrow\\mathbb{G}_T\$ be a pairing where \$\\mathbb{G}_0,\\mathbb{G}_1,\\mathbb{G}_T\$ are cyclic groups of prime order \$q\$ with generators \$g_0 \\in \\mathbb{G}_0\$ and \$g_1 \\in \\mathbb{G}_1\$. For a given adversary \$\\mathcal{A}\$, the following distribution is distinguishable: 
    \\[
    \\{g_0^{\\alpha},g_1^{\\alpha},g_0^{\\beta},g_1^{\\gamma},e(g_0,g_1)^{\\alpha\\beta\\gamma},  \\alpha,\\beta,\\gamma\\stackrel{\\\$}{\\gets}\\mathbb{Z}_q\\} \\approx^{c}
    \\{g_0^{\\alpha},g_1^{\\alpha},g_0^{\\beta},g_1^{\\gamma},e(g_0,g_1)^{\\delta},  \\alpha,\\beta,\\gamma,\\delta\\stackrel{\\\$}{\\gets}\\mathbb{Z}_q\\}
    \\]
\\end{definition}

Note that this assumption work even with \$g_0=g_1\$.

We then present our IBE construction. 
\\begin{itemize}
    \\item \$G(1^n)\$: 
    \\[
    \\alpha\\stackrel{\\\$}{\\gets}\\mathbb{Z}_q, mpk\\gets g^\\alpha, msk\\gets\\alpha
    \\]
    and output (\$mpk,msk\$)
    \\item \$K(msk=\\alpha,id)\$:
    \\[
    sk_{id}\\gets H(id)^\\alpha
    \\]
    where \$H\$ is a hash function \$H:\\{0,1\\}^{*}\\rightarrow\\mathbb{G}\$
    \\item \$E(mpk, id, m)\$: 
    \\[
    \\beta\\stackrel{\\\$}{\\gets}\\mathbb{Z}_q, c_1\\gets g^{\\beta}, c_2\\gets e(mpk,H(id)^{\\beta})\\cdot m
    \\]
    and output \$(c_1,c_2)\$.
    \\item \$D(sk_{id}, c=(c_1, c_2))\$:
    \\[
    m=\\frac{c_2}{e(c_1,sk_{id})}
    \\]
\\end{itemize}
By the property of bilinear map, we can verify the correctness of this scheme, 
\\begin{align*}
    m &= \\frac{c_2}{e(c_1,sk_{id})} \\\\
      &= \\frac{e(mpk,H(id)^{\\beta})\\cdot m}{e(c_1,sk_{id})} \\\\
      &= \\frac{e(g^\\alpha,H(id)^{\\beta})\\cdot m}{e(g^{\\beta}, H(id)^{\\alpha})} \\\\
      &= \\frac{e(g,H(id))^{\\alpha\\beta}}{e(g, H(id))^{\\alpha\\beta}}\\cdot m \\\\
      &= m
\\end{align*}

We then prove the security property under random oracle model.
\\begin{theorem}
    If decision BDH holds for e, H is modelled as a random oracle, then the above construction is a secure IBE scheme. 
\\end{theorem}
\\begin{proof}
    Let \$\\mathcal{A}\$ be an adversary that breaks the IBE scheme, we can construct another adversary \$\\mathcal{B}\$ such that it breaks the DBDH assumption.

    The adversary \$\\mathcal{B}\$ works as follows:
    \\begin{enumerate}
        \\item \$\\mathcal{B}\$ receives 5 elements as input \$\\{g^{\\alpha},g^{\\beta},g^{\\gamma},z,  \\alpha,\\beta,\\gamma\\stackrel{\\\$}{\\gets}\\mathbb{Z}_q,z\\in\\mathbb{G}\\}\$, and \$\\mathcal{B}\$ need to determine whether \$z=e(g,g)^{\\alpha\\beta\\gamma}\$ or not. 
        \\item \$\\mathcal{B}\$ send IBE public parameter \$mpk=g^{\\alpha}\$ to IBE adversary \$\\mathcal{A}\$.
        \\item Then \$\\mathcal{A}\$ will make multiple \$sk_{id}\$ queries to \$\\mathcal{B}\$. \$\\mathcal{B}\$ responds them by (1) Choose \$\\rho\\stackrel{\\\$}{\\gets}\\mathbb{Z}_q\$ (2) Setting \$H(id)=g^{\\rho}\$ (3) set the secret key be \$sk_{id}=H(id)^{\\alpha}=g^{\\rho\\cdot\\alpha}\$. One \\textbf{exception} is that \$\\mathcal{B}\$ will set a random \$id'\$ whose \$H(id')=g^\\beta\$.
        \\item After receiving the key query, \$\\mathcal{A}\$ outputs \$(id^{*}, m_0,m_1)\$.  
        \\item When \$\\mathcal{B}\$ receives encryption query \$(id^{*}, m_0, m_1)\$, it first check if \$\\mathcal{A}\$ have previously query \$sk_{id^*}\$ before, if yes, then abort. Otherwise, \$\\mathcal{B}\$ choose \$b\\stackrel{\\\$}{\\gets}\\{0,1\\}\$ and encrypt \$m_b\$ using \$(c_1=g^\\gamma, c_2=e(msk,H(id')^\\gamma)\\cdot m_b)\$ and send back to \$\\mathcal{A}\$.
        \\item \$\\mathcal{A}\$ eventually output \$b'\$ to \$\\mathcal{B}\$. And \$\\mathcal{B}\$ output \$1\$ if \$b'=b\$ and \$0\$ otherwise. 
    \\end{enumerate}
    Since \$e(msk,H(id')^{\\gamma})=e(g^\\alpha,g^{\\beta\\gamma})=e(g,g)^{\\alpha\\beta\\gamma}\$, \$\\mathcal{B}\$ can embedded the challenge to \$\\mathcal{A}\$ and break DBDH. \\qed
\\end{proof}

\\subsection{Digital Signature from IBE}
We can directly derive a secure signature scheme from IBE. 
Given a secure IBE \$\\mathcal{E}_{id}=(G,K,E,D)\$ with id space \$\\mathcal{ID}\$ and message space \$\\mathcal{M}_{IBE}\$, we construct a secure digital signature scheme \$\\mathcal{S} = (G',S',V')\$ as follows: 
\\begin{itemize}
    \\item \$G'(1^n)\$: run \$(mpk, msk)\\stackrel{\\\$}{\\gets} G(1^n)\$ and output \$(mpk, msk)\$ as the sign key pair, with \$mpk\$ as verification key and \$msk\$ as sign key.
    \\item \$S'(msk,m)\$: Given message \$m\\in\\mathcal{ID}\$, compute \$\\sigma\\stackrel{\\\$}{\\gets}K(msk,m)\$, output \$\\sigma\$ as signature. 
    \\item \$V'(mpk,m,\\sigma)\$: Choose \$r\\stackrel{\\\$}{\\gets}\\mathcal{M}_{IBE}\$, compute \$c\\stackrel{\\\$}{\\gets}E(mpk,m,r)\$, and accept if \$D(\\sigma,c) = r\$. 
\\end{itemize}

We have the following theorem,
\\begin{theorem}
    Let \$\\mathcal{E}_{id}\$ be a secure IBE with message space is super-poly. Then the derive signature scheme \$\\mathcal{S}\$ is a secure digital signature scheme. 
\\end{theorem}
\\begin{proof}
    Let \$\\mathcal{A}\$ be an adversary that breaks the digital signature scheme, we can construct another adversary \$\\mathcal{B}\$ such that breaks the IBE security.

    The BIE adversary \$\\mathcal{B}\$ is modelled as follows:
    \\begin{enumerate}
        \\item \$\\mathcal{B}\$ receives \$mpk\$ from the challenger, and forward \$mpk\$ as a signature public key to \$\\mathcal{A}\$. 
        \\item \$\\mathcal{A}\$ makes a series of signing queries \$m_0,\\dots,m_n\$ to \$\\mathcal{B}\$. \$\\mathcal{B}\$ responds by issuing the corresponding key query to the challenger and forwarding the answer back the response to \$\\mathcal{A}\$. 
        \\item \$\\mathcal{A}\$ will output a signature forgery \$(m,\\sigma)\$ which it didn't issue the sign query \$m\$. 
        \\item \$\\mathcal{B}\$ then choose two random message \$t_0,t_1\\stackrel{\\\$}{\\gets}\\mathcal{M}_{IBE}\$ and issue encryption query with the identity \$m\$.
        \\item \$\\mathcal{B} \$gets back the ciphertext \$c\\stackrel{\\\$}{\\gets}E(mpk,m,t_b)\$ for \$b\\in{0,1}\$. Then it runs \$t'\\gets D(\\sigma,c)\$ and output \$b'=t'\$. 
    \\end{enumerate}
    We observe that 
    \\begin{itemize}
        \\item when \$b = 1\$, then \$c\\stackrel{\\\$}{\\gets}E(mpk, m,t_1)\$, and \$\\mathcal{B}\$ outputs 1 with probability the same as the probability of \$\\mathcal{A}\$ breaks digital signature, we note as \$SIGadv[\\mathcal{A,S}]\$
        \\item when \$b = 0\$, then \$c\\stackrel{\\\$}{\\gets}E(mpk, m,t_0)\$, and \$\\mathcal{B}\$ outputs 1 with probability \$1/|\\mathcal{M}_{IBE}|\$ since \$\\mathcal{B}\$ can only make random guess in the message space. 
    \\end{itemize}
    We then have the probability of \$\\mathcal{B}\$ break IBE scheme
    \\[
        \\frac{1}{2}(SIGadv[\\mathcal{A,S}] + 1/|\\mathcal{M}_{IBE}|)
    \\]
    which is not negligible if \$SIGadv[\\mathcal{A,S}]\$ is not negligible. \\qed

\\end{proof}

\\section{Fully Homomorphic Encryption}
So far, we've seen private and public key encryption and different security properties (CPA, CCA). We've also seen some advanced encrpytion schemes like Identity-Based Encryption (IBE) that allow us to encrypt to an identity rather than a public key. 

Consider an example where Alice has a complex tax return to fill out and decides to use a tax return preparation service. The current pipeline is as follows:
\\begin{enumerate}
    \\item Alice sends her tax forms (W2, 1099, etc) to the service.
    \\item The service prepares the tax return and sends it back to Alice.
    \\item Alice sends the tax return to the IRS.
\\end{enumerate}
However, in this process, the service has access to all of Alice's tax information, which is a privacy concern. 

Consider an alternate scenario where Alice encrypts her tax forms before sending them to the service. It would be ideal if the service could still prepare the tax return without decrypting the forms by performing operations on the encrypted data. In this case, the service learns nothing about Alice's tax information but is still able to prepare the tax return. This is the idea behind Fully Homomorphic Encryption (FHE). FHE was first presented in [Gentry09]~\\cite{STOC:Gentry09} and has since been improved upon. We will present the construction from [GSW13]~\\cite{C:GenSahWat13}.

FHE can be defined in either private or public key settings. The below construction is defined in the private key setting for message space \$\\mathbb{Z}_2\$.

\\begin{definition}[Fully Homomorphic Encryption (FHE)]
    A FHE scheme for message space \$\\mathbb{Z}_2\$ and circuit class \$\\mathcal{C}\$ is a tuple of algorithms \$(\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec}, \\mathsf{Eval})\$ such that:
    \\begin{itemize}
        \\item \$\\mathsf{Gen}(1^\\lambda) \\rightarrow (\\ek, \\sk)\$: The key generation algorithm takes a security parameter \$\\lambda\$ and outputs a secret key \$\\sk\$ and evaluation key \$\\ek\$.
        \\item \$\\mathsf{Enc}(\\sk, m) \\rightarrow c\$: The encryption algorithm takes a public key \$\\sk\$ and message \$m\$ and outputs a ciphertext \$c\$.
        \\item \$\\mathsf{Dec}(\\sk, c) \\rightarrow m\$: The decryption algorithm takes a secret key \$\\sk\$ and ciphertext \$c\$ and outputs a message \$m\$.
        \\item \$\\mathsf{Eval}(\\ek, F, c_1, \\ldots, c_l) \\rightarrow c\$: The evaluation algorithm takes an evaluation key \$\\ek\$, a circuit \$F \\in \\mathcal{C}\$, and \$l\$ ciphertexts \$c_1, \\ldots, c_l\$ and outputs a ciphertext \$\\tilde{c}\$.
    \\end{itemize}
\\end{definition}

A FHE scheme satisfies the following properties:
\\begin{itemize}
    \\item \\textbf{Correctness}: \$\\forall n \\in \\mathbb{N},\\, \\forall F \\in \\mathcal{C},\\, \\forall (\\mu_1, \\mu_2, \\dots, \\mu_l) \\in \\mathbb{Z}_2^l\$,
    \\begin{align*}
        \\Pr[\\mathsf{Dec}(\\sk, \\mathsf{Eval}(\\ek, F, \\mathsf{Enc}(\\sk, \\mu_1), \\dots, \\mathsf{Enc}(\\sk, \\mu_l))) &= F(\\mu_1, \\mu_2, \\dots, \\mu_l)] \\\\
        &= 1 - \\text{negl}(\\lambda)
    \\end{align*}

    \\item \\textbf{Security}: The following two distributions are computationally indistinguishable:
    \\begin{align*}
        \\{(\\ek, \\mathsf{ct}_0): \\mathsf{ct}_0 \\gets \\mathsf{Enc}(\\sk, 0), (\\ek, \\sk) \\gets \\mathsf{Gen}(1^\\lambda)\\} \\\\
        \\{(\\ek, \\mathsf{ct}_1): \\mathsf{ct}_1 \\gets \\mathsf{Enc}(\\sk, 1), (\\ek, \\sk) \\gets \\mathsf{Gen}(1^\\lambda)\\}
    \\end{align*}

    \\item \\textbf{Compactness}: The size of the ciphertext \$\\mathsf{Eval}(\\ek, F, c_1, \\ldots, c_l)\$ is equal to a fresh encryption of the output of the circuit \$F\$ on the plaintexts \$\\mu_1, \\ldots, \\mu_l\$:
    \\begin{align*}
        \\forall i,\\, c_i &= \\mathsf{Enc}(\\sk, \\mu_i) \\\\
        \\lvert \\mathsf{Eval}(\\ek, F, c_1, \\ldots, c_l) \\rvert &= \\lvert \\mathsf{Enc}(\\sk, F(\\mu_1, \\ldots, \\mu_l)) \\rvert
    \\end{align*}
\\end{itemize}

The construction of FHE is based on the Learning With Errors (LWE) problem. The high-level construction is done in two steps:
\\begin{enumerate}
    \\item \\textbf{Leveled FHE}: We first construct a leveled FHE scheme that can evaluate arbitrary circuits of bounded depth.
    \\item \\textbf{Bootstrapping}: We then use the leveled FHE scheme to construct a fully homomorphic encryption scheme.
\\end{enumerate}

\\subsection{Leveled FHE}
To present some intuition for how we get homomorphic properties, consider the following construction. Let \$C \\in \\mathbb{Z}_q^{l \\times l}\$ be a matrix and \$v \\in \\mathbb{Z}_q^l\$ be an eigenvector of this matrix. The eigenvalue is chosen as the message being encrypted. \\\\
Given this, we can easily perform operations on ciphertexts that correspond to operations on the underlying plaintexts.
\\begin{itemize}
    \\item \\textbf{Addition}: Given two ciphertexts \$C_1\$ and \$C_2\$, we have \$(C_1 + C_2) v = C_1 v + C_2 v = (m_1 + m_2) v\$.
    \\item \\textbf{Multiplication}: Given two ciphertexts \$C_1\$ and \$C_2\$, we have \$(C_1 \\cdot C_2) v = C_1 (C_2 v) = C_1 (m_2 v) = m_1 m_2 v\$.
\\end{itemize}
Note that this is not a secure construction as presented, since with enough samples we can solve a linear system to obtain the secret key. However, this gives us some intuition for how we can perform operations on encrypted data. To make this construction secure, we need to add noise to the ciphertexts (which is where LWE comes in). \\\\
However, a naive way of doing this does not work; suppose we have that \$Cv = m v + e\$ where \$e\$ is the (small) noise term. Then, even a single multiplication gives us \$C_1 C_2 v = m_1 m_2 v + C_1 e_2\$, where the noise term is no longer guaranteed to be small since \$C\$ has no such guarantees.

The construction of the leveled FHE scheme is as follows. We use the LWE problem with parameters \$(n, m, q, \\chi)\$ where \$n\$ is the dimension of the secret key, \$m\$ is the dimension of the public key, \$q\$ is the modulus, and \$\\chi\$ is the noise distribution. The scheme is defined for message space \$\\mathbb{Z}_2\$. Additionally, set \$l = (n+1) \\log q\$.
\\begin{itemize}
    \\item \$\\mathsf{Gen}(1^\\lambda) \\rightarrow (\\ek, \\sk)\$: Sample \$s' \\gets \\mathbb{Z}_q^{n}\$ and set \$s =  
    \\begin{bmatrix}
        -s' \\\\
        1
    \\end{bmatrix} \\in \\mathbb{Z}_q^{n+1}\$. 

    \\item \$\\mathsf{Enc}(\\sk \\in \\mathbb{Z}_q^{n+1}, m \\in \\mathbb{Z}_2) \\rightarrow C \\in \\mathbb{Z}_q^{l \\times (n+1)}\$: Sample \$A \\gets \\mathbb{Z}_q^{l \\times n}\$ and \$e \\gets \\chi^{l}\$. Define \$B = A \\| As' + e\$ and \$C = B + m \\cdot G\$ for a fixed gadget~\\cite{EC:MicPei12} matrix \$G \\in \\mathbb{Z}_q^{l \\times (n+1)}\$.
    
    \\begin{itemize}
        \\item Note that by choice of \$B\$, we have that \$Bs = A(-s') + A(s') + e = e\$ is an encryption of zero (with noise). Similarly, \$Cs = Bs + mGs = e + mGs\$. 
        \\item \$G\$ is a block matrix containing \$(n+1)\$ block column vectors of size \$\\log q\$ each. Each vector is \$g = (1, 2, 4, \\ldots, 2^{\\log q - 1})\$. Concisely, we can define \$G = I_{n+1} \\otimes g\$ where \$\\otimes\$ is the Kronecker product.
        \\item We also define a \$\\mathsf{Flatten}\$ operation on the ciphertext that converts \$C \\in \\mathbb{Z}_q^{l \\times (n+1)}\$ to \$\\tilde{C} \\in \\mathbb{Z}_q^{l \\times l}\$ by bit decomposing each element of \$C\$ and replacing the element with its bit vector. \\\\
        This ensures that each element of this matrix is a bit. Looking ahead, this allows us to multiply ciphertexts without too much noise growth.
    \\end{itemize}
    
\\end{itemize}
% Add Eval + and x, noting the noise growth of each 
\\begin{itemize}
    \\item \$\\mathsf{Dec}(s, C)\$: Compute \$v = Cs\$. If \$||v||_\\infty < q/4\$, i.e. each entry of \$v\$ is less than \$q/4\$, output \$0\$, else output \$1\$. (Note the exact choice of threshold is somewhat arbitrary.)
    
    \\item \$\\mathsf{Eval}(+, C_1, C_2)\$: Output \$C = C_1 + C_2\$. 

    \\begin{itemize}
        \\item Notice that \$Cs = C_1s + C_2s = (m_1 Gs + e_1) + (m_2 G + e_2) = (m_1 + m_2) Gs + (e_1 + e_2)\$. 

        \\item Thus if the original ciphertexts errors \$||e_1||_{\\infty}, ||e_2||_{\\infty} \\leq B\$, then the new cipertext error is bounded by \$2B\$. 
    \\end{itemize} 

    \\item \$\\mathsf{Eval}(+, C_1, C_2)\$: Output \$C = \\mathsf{Flatten}(C_1) \\times C_2\$. 

    \\begin{itemize}
        \\item We utilize the \$\\mathsf{Flatten}\$ operation so that the dimensions match for matrix multiplication. 

        \\item Notice that 
        \\begin{align*}
            Cs & = \\mathsf{Flatten}(C_1) \\times C_2 s \\\\
            & = \\mathsf{Flatten}(C_1) \\times (m_2 G s + e_2) \\\\ 
            & = m_2 (\\mathsf{Flatten}(C_1) G) s + \\mathsf{Flatten}(C_1) e_2 \\\\ 
            & = m_2 (C_1 s) + \\mathsf{Flatten}(C_1) e_2 \\\\
            & = m_2 (m_1 Gs + e_1) + \\mathsf{Flatten}(C_1) e_2 \\\\ 
            & = (m_1 m_2) G s + (m_2 e_1 + \\mathsf{Flatten}(C_1) e_2). 
        \\end{align*} 

        \\item Since each entry of \$\\mathsf{Flatten}(C_1)\$ is in \$\\{0,1\\}\$, each entry of \$\\mathsf{Flatten}(C_1) e_2\$ is a subset sum of \$e_2 \\in \\mathbb{Z}_q^{\\ell}\$. Thus if the original ciphertexts errors \$||e_1||_{\\infty}, ||e_2||_{\\infty} \\leq B\$, then the new ciphertext error is bounded by \$(1+\\ell)B\$. 
    \\end{itemize}
\\end{itemize}

% Analyze overall noise growth 

Notice that as \$\\mathsf{Eval}\$ is applied iteratively to ciphertexts in order to implement an arithmetic circuit of depth \$d\$, the noise will stay bounded by \$(\\ell+1)^d B\$. 
As long as the error stays below the threshold used by \$\\mathsf{Dec}\$, i.e. \$(\\ell+1)^d B << q/4\$, then correctness will hold. 
Recall that \$\\ell = (n+1) \\log(q)\$ where \$q\$ is typically exponential in \$n\$. 
Then the error will be manageable as long as \$d\$ is sublinear in \$n\$, e.g. \$d = n^{0.99}\$. 

Further, notice that since swapping ordering of \$C_1\$ vs \$C_2\$ changes the noise growth of multiplication from \$m_2 e_1 + \\mathsf{Flatten}(C_1) e_2\$ to \$m_1 e_2 + \\mathsf{Flatten}(C_2) e_1\$, we can optimize based on which ciphertext started with more noise than the other. 
This can be leveraged to get polynomial noise growth instead of exponential. 

% Add Eval for NAND 

Now, we have cheated slightly in the above---notice that our construction for \$\\mathsf{Eval}(+, C_1, C_2)\$ implements addition mod \$q\$, but we actually wanted addition mod 2. 
One way to address this is to simply implement NAND, which on its own is a complete gate set that can implement any circuit: 
\\begin{itemize}
    \\item \$\\mathsf{Eval}(\\text{NAND}, C_1, C_2)\$: Output \$C = I - \\mathsf{Flatten}(C_1) \\times C_2\$. 
\\end{itemize}

Altogether, we have achieved \\emph{leveled} FHE. 

% Present bootstrapping and how it ensures noise doesn't grow too large 

\\subsection{Bootstrapping} 

The goal of bootstrapping is to reset the ciphertext's noise back to a lower level after it has built up too much. 
This is done by letting the server re-encrypt the ciphertext \\emph{without} using the secret key \$s\$. 
How is this possible? 
Simply evaluate \$\\mathsf{Dec}\$ homomorphically! 
In particular, let \$P_{\\mathsf{Dec}, C}\$ be a circuit which on input \$s\$ outputs \$m = \\mathsf{Dec}(s, C)\$. 
Let \$s_1, s_2, \\ldots, s_{\\ell} \\in {0,1}\$ be \$s\$ written in binary. 
We will set the evaluation key \$ek = (ek_1, \\ldots, ek_{\\ell})\$ for \$ek_i = \\mathsf{Enc}(s, s_i)\$, i.e. it gives us an encrypted copy of the secret key. 
Then whenever we need to reduce the noise of a ciphertext \$C\$, we can compute \$P_{\\mathsf{Dec}, C}\$ and run \$\\mathsf{Eval}(P_{\\mathsf{Dec}, C}, ek_1 \\ldots ek_\\ell)\$ to get a fresh ciphertext \$\\hat{C}\$. 
Notice that the noise of \$\\hat{C}\$ only depends on the noise of the input ciphertexts \$ek_i\$, which are fresh, and the depth \$d_P\$ of the circuit \$P_{\\mathsf{Dec}, C}\$, which is independent of the noise of \$C\$. 
Thus \$\\hat{C}\$ will have noise bounded by \$(\\ell + 1)^{d_P} B\$. 
As long as our leveled scheme supports circuits of depth \$d_p+1\$, we can achieve arbitrary depth by bootstrapping after each operation. 
Of course, we'd like to avoid this as much as possible since doing the decryption operation homomorphically is expensive. 

% Circular security issue 

In order for this approach to work, security needs to be maintained even though we're releasing encryptions of the secret key. 
This is known as \\emph{circular security}. 
There are no known attacks on circular security for GSW and other commonly used leveled FHE constructions. 
However, they have not been proven to be circularly secure, and there are encryption schemes for which circular security is known to not hold for certain cycle lengths. 
An alternative is using a new secret key to encrypt the old secret key. 

% Construction of CCA-2 secure IBE 

\\section{CCA-2 Secure Encryption from IBE} 

Finally, we will see how to utilize CPA secure IBE to construct not only CCA-1 but CCA-2 secure encryption. 
Let \$(G, K, E, D)\$ be a CPA secure IBE scheme and \$(\\mathsf{Gen}_{sig}, \\mathsf{Sign}, \\mathsf{Verify})\$ be a digital signature scheme. 
Then construct a CCA-2 secure encryption scheme as follows: 
\\begin{itemize}
    \\item \$\\mathsf{KeyGen}(1^n)\$: 
    \\begin{enumerate}
        \\item Compute \$(pk, sk) \\leftarrow G(1^n)\$. 
        
        \\item Output \$pp = pk\$ and \$msk = sk\$. 
    \\end{enumerate}

    \\item \$\\mathsf{Enc}(pk, m)\$: 
    \\begin{enumerate}
        \\item \\textbf{Compute \$(vk_s, sk_s) \\leftarrow Gen_{sig}(1^n)\$.}
        
        \\item \\textbf{Let \$id = vk_s\$.}

        \\item Let \$c = E(pp, id, m)\$. 

        \\item \\textbf{Compute \$\\sigma = \\mathsf{Sign}(sk_s, c)\$.} 

        \\item \\textbf{Output \$(id, c, \\sigma)\$.} 
    \\end{enumerate}

    \\item \$\\mathsf{Dec}(sk, (id,c,\\sigma))\$: 
    \\begin{enumerate}
        \\item \\textbf{If \$\\mathsf{Verify}(id, c, \\sigma) = 0\$ then abort.} 

        \\item Compute \$sk_{id} \\leftarrow K(sk, id)\$. 

        \\item Output \$D(sk_{id}, c)\$. 
    \\end{enumerate}
\\end{itemize}
The bolded lines are the ones that have been changed compared to the CCA-1 construction. 
The changes restrict you to only generating ciphertexts for \$id\$'s you sampled yourself. 
Note that for this construction we need slightly stronger forgery protection for the digital signature scheme than we've considered previously. 
Namely, in the forgery security game the attacker is now allowed to output \$(m^*, \\sigma^*)\$ as long as the tuple is fresh, even if \$m^*\$ on its own is not. 
Notice that this stronger notion holds for any deterministic signature scheme, including the BLS scheme we saw. 
It is also sufficient for our purposes here to utilize a one-time signature scheme. 

